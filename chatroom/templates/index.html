<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.3/css/all.css" integrity="sha384-SZXxX4whJ79/gErwcOYf+zWLeJdY/qpuqC4cAa9rOGUstPomtqpuNWT9wdPEn2fk" crossorigin="anonymous">
    <style>
        body, html{
            height: 100%;
            width: 100%;
        }
        .card-header{
            height: 50px;
        }
        .chat-bubble{
            border-radius: 5px;
            padding: 5px;
        }
        .sent{
            float: right;
            color: white;
            max-width: 40rem;
            background-color: rgba(61, 139, 241, 1);
        }
        .received{
            float: left;
            color: black;
            max-width: 40rem;
            background-color: rgba(229, 229, 234, 1);
        }
        .separator{
            clear: both;
            background-color: gray;
        }
        .message-box{
            max-height: 150px;
            overflow: auto;
        }
        [contenteditable=true]:empty:before {
            content: attr(placeholder);
            pointer-events: none;
            color: #636c72;
            display: block; /* For Firefox */
        }
        .my-x-button{
            display: none;
        }
        .my-user-button:hover .my-x-button{
            display: block;
        }
    </style>
    <title>Document</title>
</head>
<body>

    <div class="container-fluid h-100 m-0 my-container">
        <div class="row h-100 my-row">
            <div class="col-3 p-0 my-col">

                <!--
                    Touch ups:
                    1.) Make sidebar card a bluish color with white text
                    2.) Translucent badge counters
                    3.) Make search bar translucent
                -->

                <!--Sidebar card-->
                <div class="card h-100 rounded-0">
                    <div class="card-header">
                        <div class="input-group input-group-sm">
                            <span class="input-group-text bg-white border" id="inputGroup-sizing-sm">
                                <i class="fas fa-search"></i>
                            </span>
                            <input type="search" class="form-control" placeholder="Type to search..." id="search-bar"/>
                        </div>
                    </div>
                    <div class="card-body overflow-scroll p-0" style="height: 1px;">
                        <div class="list-group list-group-flush" id="user-area">
                            <!--Users go here-->
                        </div>
                    </div>
                    <div class="card-footer">
                        <!-- Button toggle for modal -->
                        <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#addUserModal" id="modal-button">
                            <i class="fas fa-user-plus"></i>
                        </button>

                        <!-- Modal -->
                        <div class="modal fade" id="addUserModal" tabindex="-1">
                            <div class="modal-dialog modal-dialog-scrollable">
                                <div class="modal-content">
                                    <div class="modal-header">
                                        <h5 class="modal-title">Select a classmate to chat with</h5>
                                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                                    </div>
                                    <div class="modal-body">
                                        <div class="list-group" id="modal-classmate-area">
                                            <!--Classmate names go here-->
                                        </div>
                                    </div>
                                    <div class="modal-footer">
                                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
            <div class="col-9 p-0 my-col">

                <!--Chat card-->
                <div class="card h-100 rounded-0">
                    <div class="card-header" id="recipient-area">
                        <!--Recipient name goes here-->
                    </div>
                    <div class="card-body overflow-auto" style="height: 1px;" id="message-area">
                        <!--Messages go here-->
                        <h1>Welcome</h1>
                    </div>
                    <div class="card-footer">
                        <div id="text-submit" class="form-control message-box" contenteditable="true" placeholder="Message..."></div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- content -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js" integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-cookie@rc/dist/js.cookie.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.js"></script>

    {% csrf_token %}
    <script>
        /*
        ***********************************************************************
        SECURITY TOKENS & CONSTANTS
        ***********************************************************************
        */

        const csrftoken = Cookies.get('csrftoken');

        /*
        ***********************************************************************
        PRIVATE HELPER FUNCTIONS        
        ***********************************************************************
        */

        function closest(elem, tagname){
            do {
                if (elem.tagName === tagname) return elem;
                elem = elem.parentNode;
            } while (elem);
        }


        /*
        ***********************************************************************
        CACHED DOM ELEMNTS
        ***********************************************************************
        */

        let userArea_div = document.getElementById("user-area");
        let recipientArea_div = document.getElementById("recipient-area");
        let messageArea_div = document.getElementById("message-area");
        let textSubmitArea_div = document.getElementById("text-submit");
        let modalClassmateArea_div = document.getElementById("modal-classmate-area");
        let modal_btn = document.getElementById("modal-button");
        let searchBar_input = document.getElementById("search-bar");

        /*
        ***********************************************************************
        DYNAMIC HTML ELEMENTS
        ***********************************************************************
        */

        let createUserElem = function(user, count){
            return `<button type="button" class="d-flex list-group-item list-group-item-action justify-content-between align-items-center my-user-button">
                        <span class="text-truncate">
                            <i class="fas fa-user-circle me-2"></i>
                            <span>${user}</span>
                        </span>
                        <span type="span-close-button" class="btn-close my-x-button"></span>
                    </button>`;
        }
        let createToElem = function(to){
            return `<p class="fs-4 p-0 m-0">To: <span id="recipient-area">${to}</span></p>`
        }
        let createSentMessageElem = function(message){
            return `<p class="chat-bubble received text-wrap">${message}</p>
                    <div class="separator"></div>`;
        }
        let createReceivedMessageElem = function(message){
            return `<p class="chat-bubble sent text-wrap">${message}</p>
                    <div class="separator"></div>`;
        } 
        let createModalClassmateElem = function(classmate){
            return `<button type="button" class="list-group-item list-group-item-action" data-bs-dismiss="modal">${classmate}</button>`;
        } 

        /*
        ***********************************************************************
        INIT FUNCTIONS
        ***********************************************************************
        */

        function getActiveUser(){

             /*
              * Right now this is just dummy data but in the future
              * this information should be retrieved from the student model
              */

            let email = prompt("Enter your name: ");
            return email;
        }

        function getClassmates(activeUser){

             /*
              * Right now this is just dummy data but in the future
              * this information should be retrieved from the backend database
              */
             
            let classmates = [
                "jacob",
                "ben",
                "mark",
                "donny",
                "bill",
                "joe",
                "gage"
            ];

            // remove active user from list
            classmates.splice(classmates.indexOf(activeUser), 1);

            return classmates;
        }

        async function getUserList(activeUser, classmates){
            const otherUsers = await fetch_user_list(activeUser);
            for(let i = 0; i <= otherUsers.length; i++){
                let otherUser = otherUsers[i];
                if(classmates.includes(otherUser)){
                    classmates.splice(classmates.indexOf(otherUser), 1);
                }
            }
            return otherUsers;
        }

        function getOtherUser(){
            return ( recipientArea_div.children.length != 0 ) ? recipientArea_div.children[0].children[0].innerHTML : '';
        }

        /*
        ***********************************************************************
        ATTACH/CHAIN DYNAMIC HTML ELEMENTS TO DOM
        ***********************************************************************
        */

        function attachMessageListToMessageDiv(messages, user){
            // create HTML list
            let htmlList = messages.reduce( (htmlList, messageObj)=> {
                if(messageObj.from_id === user){
                    htmlList += createReceivedMessageElem(messageObj.message);
                } else{
                    htmlList += createSentMessageElem(messageObj.message);
                }
                return htmlList;
            }, '');
            // attach html list to modal div
            messageArea_div.innerHTML = htmlList;
            messageArea_div.scrollTop = messageArea_div.scrollHeight;
        }

        function attachClassmateListToModalDiv(classmates){
            // create HTML list
            let htmlList = classmates.reduce( (htmlList, classmate)=> {
                let elem = createModalClassmateElem(classmate, 0);
                htmlList += elem;
                return htmlList;
            }, '');
            // attach html list to modal div
            modalClassmateArea_div.innerHTML = htmlList;
        }

        function attachUserListToUserDiv(otherUsers){
            // create HTML list
            let htmlList = otherUsers.reduce( (htmlList, otherUser)=> {
                let elem = createUserElem(otherUser, 0);
                htmlList += elem;
                return htmlList;
            }, '');
            // attach html list to modal div
            userArea_div.innerHTML = htmlList;
        }

        function attachEmptyElemToMessageDiv(){
            messageArea_div.innerHTML = '';
        }

        function attachRecipientElemToRecipientDiv(recipient){
            // create HTML recipient element
            let elem = createToElem(recipient);
            recipientArea_div.innerHTML = elem;
        }

        function chainSentMessageToMessageDiv(message){
            // create HTML recipient element
            let elem = createSentMessageElem(message);
            messageArea_div.innerHTML += elem;
            messageArea_div.scrollTop = messageArea_div.scrollHeight;
        }

        function chainRecievedMessageToMessageDiv(message){
            // create HTML recipient element
            let elem = createReceivedMessageElem(message);
            messageArea_div.innerHTML += elem;
            messageArea_div.scrollTop = messageArea_div.scrollHeight;
        }

        /*
        ***********************************************************************
        DATABASE CONNECTION FUNCTIONS
        ***********************************************************************
        */

        async function fetch_conversation(activeUser, otherUser){
            // POST- update db
            const request = {
                method: 'POST',
                credentials: 'same-origin',
                headers: {
                    'Accept': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest', 
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify({
                    from: activeUser,
                    to: otherUser
                })
            };

            const response = await fetch('retrieve_conversation/', request);
            const messageList = await response.json();

            return messageList;
        }

        async function fetch_user_list(activeUser){
            // POST- update db
            const request = {
                method: 'POST',
                credentials: 'same-origin',
                headers: {
                    'Accept': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest', 
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify({
                    activeUser
                })
            };

            const response = await fetch('retrieve_user_list/', request);
            const jsonArray = await response.json();
            const userList = jsonArray.map( obj => obj.other_user );

            return userList;
        }

        async function send_user_list(activeUser, otherUsers){
            // POST- update db
            const request = {
                method: 'POST',
                credentials: 'same-origin',
                headers: {
                    'Accept': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest', 
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify({
                    activeUser,
                    otherUsers
                })
            };

            const response = await fetch('load_user_list/', request);
        }

        async function send_message(message, activeUser, otherUser){
            // udpate DOM
            chainSentMessageToMessageDiv(message);

            // POST- update db
            const request = {
                method: 'POST',
                credentials: 'same-origin',
                headers: {
                    'Accept': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest', 
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify({
                    message: message,
                    from: activeUser,
                    to: otherUser
                })
            };

            const response = await fetch('load_message/', request);
        }

        async function poll_message(activeUser, otherUser){

            /*
             * Only poll for unseen messages if a recipient has been
             * chosen by the active user, otherwise don't send POST
             * request
             */

            if (otherUser !== '') {
                // POST- retrieve from db
                const request = {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: {
                        'Accept': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest', 
                        'X-CSRFToken': csrftoken
                    },
                    body: JSON.stringify({
                        from: otherUser,
                        to: activeUser
                    })
                };

                // retrieve all unseen messages sent from other user to active user
                const response = await fetch('retrieve_message/', request);
                const jsonArray = await response.json();

                // update DOM
                for(let i = 0; i < jsonArray.length; i++){
                    let message = jsonArray[i]['message'];
                    chainRecievedMessageToMessageDiv(message);
                }
            } 
        }

        async function poll_conversation(activeUser, classmate, otherUsers, classmates){

            /*
             * poll for entire conversation between user who has
             * not been selected from the classmates list. Once conversation
             * has been polled, see if there are any messages that have not been
             * seen and post the converstaion if so. Otherwise keep polling for new
             * unseen messages
             */

            // POST- retrieve from db
            if(classmates.length !== 0){
                // POST- retrieve from db
                const messageList = await fetch_conversation(activeUser, classmate);
                const unseenMessageList = messageList.filter( messageObj => messageObj.seen === false );

                if(unseenMessageList.length !== 0){
                    // update otherUsers list and remove user from classmates
                    otherUsers.unshift(classmate);
                    classmates.splice(classmates.indexOf(classmate), 1);
                    // update DOM elements
                    attachUserListToUserDiv(otherUsers);
                }
            }
        }

        /*
        ***********************************************************************
        EVENTS        
        ***********************************************************************
        */

        async function modalButtonEvent(e, activeUser, classmates, otherUsers){
            if (e.target === e.currentTarget) return;

            // get index of target button
            let buttons = e.currentTarget.children;
            let index = Array.from(buttons).indexOf(e.target);

            // put classmate into otherUsers and remove classmate from its list
            otherUser = classmates[index];
            otherUsers.push(classmates[index]);
            classmates.splice(index, 1);

            // get cnversation
            const messageList = await fetch_conversation(activeUser, otherUser);

            // update user area
            attachUserListToUserDiv(otherUsers);
            attachRecipientElemToRecipientDiv(otherUser);
            attachMessageListToMessageDiv(messageList, otherUser);

            e.stopPropagation();
        }

        async function userButtonEvents(e, activeUser, otherUsers, classmates){
            if (e.target === e.currentTarget) return;

            // get span button element from element that was clicked
            let button = closest(e.target, 'BUTTON');                
            let otherUser = button.children[0].children[1].innerHTML

            // close button or user button
            if(e.target.getAttribute('type') === "span-close-button"){
                // update otherUsers and classmates list
                let index = otherUsers.indexOf(otherUser);
                otherUsers.splice(index, 1);
                classmates.push(otherUser);
                let nextOtherUser = otherUsers[index];

                // update DOM
                attachUserListToUserDiv(otherUsers);
                if(otherUsers.length === 0 || index >= otherUsers.length){
                    attachEmptyElemToMessageDiv();
                    attachRecipientElemToRecipientDiv('');
                } else{
                    attachRecipientElemToRecipientDiv(nextOtherUser);
                    attachEmptyElemToMessageDiv();
                    const messageList = await fetch_conversation(activeUser, nextOtherUser);
                    attachMessageListToMessageDiv(messageList, nextOtherUser);
                }
            } else{
                // update DOM
                const messageList = await fetch_conversation(activeUser, otherUser);
                attachRecipientElemToRecipientDiv(otherUser);
                attachMessageListToMessageDiv(messageList, otherUser);
            }

            e.stopPropagation();
        }

        function inputMessageEvent(e, activeUser, otherUser){
            if(e.key === 'Enter'){
                // prevent default page load on keypress
                e.preventDefault();
                // get the current message
                let message = e.target.innerHTML;
                // get the placeholder
                let attr = textSubmitArea_div.getAttributeNode('placeholder');

                /*
                 * If a recipient has been selected than send them the message
                 * otherwise tell the active user to select a recipient before
                 * sending a message
                 */

                if (otherUser !== '') {
                    send_message(message, activeUser, otherUser);
                    attr.textContent = "Message...";
                } else {
                    attr.textContent = "You must select a user before sending a message...";
                }

                /*
                 * Remove the message from the text area after it has been
                 * sent and always keep most recent messages in focus by
                 * scrolling to the bottom of the message area div
                 */
                
                e.target.innerHTML = '';
                messageArea_div.scrollTop = messageArea_div.scrollHeight;
            }
        }

        function searchBarEvent(e, otherUsers, filteredUsers){
            e.preventDefault();
            let query = e.target.value;

            /*
             * Below we are using Fuse.js- a fuzzy search algorithm in order
             * to properly implement the search functionality. The result of 
             * the search algorithm is an array of values that match the give 
             * search value in order of closest match
             */

            const fuse = new Fuse(otherUsers);
            const result = fuse.search(query);
            const filter = result.map( (o) => { return o.item; } );

            if(query !== ''){
                // show filtered search
                attachUserListToUserDiv(filter);
            } else{
                // show full user list
                attachUserListToUserDiv(otherUsers);
            }
        }

        async function unloadEvent(e, activeUser, otherUsers){
            send_user_list(activeUser, otherUsers);
        }

        // attach event handlers
        async function main(){
            // get active user, classmates, and a list of other users
            let activeUser = getActiveUser();
            let classmates = getClassmates(activeUser);
            let otherUsers = await getUserList(activeUser, classmates);

            // default DOM updates
            attachUserListToUserDiv(otherUsers);

            // add-new-user button event
            modal_btn.addEventListener('click', (e) => { attachClassmateListToModalDiv(classmates); }, false);
            // modal button event
            modalClassmateArea_div.addEventListener('click', (e) => { modalButtonEvent(e, activeUser, classmates, otherUsers); }, false);
            // user button event
            userArea_div.addEventListener('click', (e) => { userButtonEvents(e, activeUser, otherUsers, classmates); }, false);
            // message input area event
            textSubmitArea_div.addEventListener('keypress', (e) => { inputMessageEvent(e, activeUser, getOtherUser()); }, false);
            // search bar event
            searchBar_input.addEventListener('input', (e)=>{ searchBarEvent(e, otherUsers); }, false);
            // close window event
            window.addEventListener('beforeunload', (e)=>{ unloadEvent(e, activeUser, otherUsers); }, false);

            // poll for new messages
            setInterval(() => {
                poll_message(activeUser, getOtherUser());
            }, 100);

            // poll for new conversations from classmate list
            setInterval(() => {
                classmates.forEach( (classmate) => {
                    poll_conversation(activeUser, classmate, otherUsers, classmates);
                }); 
            }, 400);

            //// poll for new conversations from otherUsers list
            //setInterval(() => {
            //    otherUsers.forEach( (otherUser) => {
            //        poll_conversation(activeUser, classmate, otherUsers, classmates);
            //    }); 
            //}, 400);
        }

        // 1.) create a new message dot feature- must work for messages sent from classmates in classmate list
        //     and for new messages sent by the otherUsers list
        // 2.) create a helper function for post requests

        // run app
        main();
    </script>

</body>
</html>



